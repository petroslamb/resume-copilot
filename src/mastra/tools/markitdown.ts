import { createTool } from "@mastra/core/tools";
import { MCPClient } from "@mastra/mcp";
import { RuntimeContext } from "@mastra/core/runtime-context";
import type { ToolsInput } from "@mastra/core/agent";
import type { MastraMCPServerDefinition } from "@mastra/mcp/dist/client/client";
import { z } from "zod";

const MARKITDOWN_TOOL_ID = "markitdown_convert_to_markdown";
const DEFAULT_MARKITDOWN_URL = "http://127.0.0.1:3001/mcp";
const DEFAULT_TIMEOUT = 120_000;

let markitdownClient: MCPClient | null = null;
let markitdownToolsPromise: Promise<ToolsInput> | null = null;
let localFallbackToolset: ToolsInput | null = null;
let pdfParseLoader: Promise<(input: Buffer) => Promise<{ text: string }>> | null = null;

function parseTimeout(): number {
  const value = process.env.MARKITDOWN_MCP_TIMEOUT;
  if (!value) {
    return DEFAULT_TIMEOUT;
  }
  const parsed = Number.parseInt(value, 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : DEFAULT_TIMEOUT;
}

function parseHeaders(): Record<string, string> | undefined {
  const raw = process.env.MARKITDOWN_MCP_HEADERS;
  if (!raw) {
    return undefined;
  }

  try {
    const parsed = JSON.parse(raw) as Record<string, unknown>;
    return Object.fromEntries(
      Object.entries(parsed).map(([key, value]) => [key, String(value)]),
    );
  } catch (error) {
    console.warn(
      "[markitdown] Failed to parse MARKITDOWN_MCP_HEADERS as JSON. Expected object of header key/value pairs.",
      error,
    );
    return undefined;
  }
}

function resolveServerDefinition(timeout: number): MastraMCPServerDefinition {
  const rawUrl = process.env.MARKITDOWN_MCP_URL?.trim() ?? DEFAULT_MARKITDOWN_URL;

  let url: URL;
  try {
    url = new URL(rawUrl);
  } catch (error) {
    throw new Error(
      `Invalid MARKITDOWN_MCP_URL value '${rawUrl}'. Provide a fully qualified URL (e.g. http://127.0.0.1:3001/mcp).`,
      error instanceof Error ? { cause: error } : undefined,
    );
  }

  const headers = parseHeaders();

  return {
    url,
    timeout,
    requestInit: headers ? { headers } : undefined,
  };
}

async function ensureClient(): Promise<MCPClient> {
  if (markitdownClient) {
    return markitdownClient;
  }

  const timeout = parseTimeout();
  const serverDefinition = resolveServerDefinition(timeout);

  markitdownClient = new MCPClient({
    servers: {
      markitdown: serverDefinition,
    },
    timeout,
  });

  return markitdownClient;
}

async function ensureTools(): Promise<ToolsInput> {
  if (markitdownToolsPromise) {
    return markitdownToolsPromise;
  }

  markitdownToolsPromise = (async () => {
    const client = await ensureClient();
    const tools = await client.getTools();

    if (!tools[MARKITDOWN_TOOL_ID]) {
      throw new Error(
        `MarkItDown MCP server did not expose '${MARKITDOWN_TOOL_ID}'. Ensure the server is running and reachable.`,
      );
    }

    return tools;
  })();

  try {
    return await markitdownToolsPromise;
  } catch (error) {
    markitdownToolsPromise = null;
    throw error;
  }
}

function extractMarkdown(callResult: unknown): string {
  if (typeof callResult === "string") {
    return callResult;
  }

  if (
    callResult &&
    typeof callResult === "object" &&
    "content" in callResult &&
    Array.isArray((callResult as { content: unknown }).content)
  ) {
    const { content } = callResult as { content: Array<Record<string, unknown>> };
    for (const item of content) {
      if (typeof item?.text === "string") {
        return item.text;
      }
    }
  }

  throw new Error("MarkItDown MCP response did not include text content.");
}

export async function getMarkitdownTools(): Promise<ToolsInput> {
  try {
    return await ensureTools();
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error while loading MarkItDown tools.";
    console.warn(
      `[markitdown] Remote tool unavailable; using local fallback implementation. Reason: ${message}`,
    );

    if (localFallbackToolset) {
      return localFallbackToolset;
    }

    const fallbackTool = createTool({
      id: MARKITDOWN_TOOL_ID,
      description:
        "Convert PDF data URIs into markdown using a local parser when the MarkItDown MCP server is unavailable.",
      inputSchema: z.object({
        uri: z
          .string()
          .min(1, "Provide a data URI to convert to markdown.")
          .describe("Data URI (base64) representation of the PDF document."),
      }),
      outputSchema: z.object({
        markdown: z
          .string()
          .describe("Extracted markdown text generated by the local PDF parser."),
        note: z
          .string()
          .optional()
          .describe("Status message describing limitations of the local parser."),
      }),
      execute: async ({ context }) => {
        const markdown = await convertUriToMarkdown(context.uri, { preferLocal: true });
        return {
          markdown,
          note:
            "Converted using local PDF parser fallback. Formatting may differ from MarkItDown output.",
        };
      },
    });

    localFallbackToolset = {
      [MARKITDOWN_TOOL_ID]: fallbackTool,
    };

    return localFallbackToolset;
  }
}

interface ConvertOptions {
  preferLocal?: boolean;
}

export async function convertUriToMarkdown(
  uri: string,
  options?: ConvertOptions,
): Promise<string> {
  if (!uri || typeof uri !== "string") {
    throw new Error("A non-empty URI is required to convert with MarkItDown.");
  }

  if (!options?.preferLocal) {
    try {
      const tools = await ensureTools();
      const tool = tools[MARKITDOWN_TOOL_ID];

      if (!tool?.execute) {
        throw new Error(
          "MarkItDown tool is not executable. Verify the MCP server configuration.",
        );
      }

      const runtimeContext = new RuntimeContext();
      const result = await tool.execute(
        {
          context: { uri },
          runtimeContext,
        },
        undefined,
      );

      return extractMarkdown(result);
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "MarkItDown MCP request failed unexpectedly.";
      console.warn(
        `[markitdown] Remote conversion failed. Attempting local PDF fallback. Reason: ${message}`,
      );
      const fallback = await tryLocalPdfFallback(uri);
      if (fallback) {
        return fallback;
      }

      throw new Error(
        `MarkItDown MCP failed (${message}) and no local fallback conversion was available.`,
      );
    }
  }

  const fallback = await tryLocalPdfFallback(uri);
  if (fallback) {
    return fallback;
  }

  throw new Error(
    "Local MarkItDown fallback only supports PDF data URIs. Provide a PDF or configure the MCP server.",
  );
}

export function resetMarkitdownClientForTests(): void {
  markitdownClient = null;
  markitdownToolsPromise = null;
  localFallbackToolset = null;
  pdfParseLoader = null;
}

interface ParsedDataUri {
  mimeType: string;
  buffer: Buffer;
}

const DATA_URI_REGEX = /^data:([^;]+);base64,(.+)$/i;

function parseDataUri(uri: string): ParsedDataUri | null {
  const match = uri.match(DATA_URI_REGEX);
  if (!match) {
    return null;
  }

  const [, mimeType, base64] = match;
  try {
    return {
      mimeType,
      buffer: Buffer.from(base64, "base64"),
    };
  } catch {
    return null;
  }
}

async function tryLocalPdfFallback(uri: string): Promise<string | null> {
  const parsed = parseDataUri(uri);
  if (!parsed || parsed.mimeType.toLowerCase() !== "application/pdf") {
    return null;
  }

  try {
    const pdfParse = await loadPdfParse();
    const result = await pdfParse(parsed.buffer);
    const normalized = normalizePdfText(result.text);
    if (normalized) {
      return normalized;
    }
    return "_No textual content could be extracted from the PDF._";
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error during local PDF parsing.";
    console.error(`[markitdown] Local PDF fallback failed: ${message}`, error);
    throw new Error(`Local PDF fallback failed: ${message}`);
  }
}

function normalizePdfText(text: string): string {
  const normalized = text
    .replace(/\r\n/g, "\n")
    .split("\n")
    .map((line) => line.trimEnd())
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  if (!normalized) {
    return "";
  }

  const paragraphs = normalized
    .split(/\n{2,}/)
    .map((paragraph) => paragraph.replace(/\n/g, " ").replace(/\s{2,}/g, " ").trim())
    .filter(Boolean);

  return paragraphs.length > 0 ? paragraphs.join("\n\n") : normalized;
}

async function loadPdfParse(): Promise<(input: Buffer) => Promise<{ text: string }>> {
  if (!pdfParseLoader) {
    pdfParseLoader = import("pdf-parse").then((module) => {
      const candidate =
        typeof module === "function"
          ? module
          : typeof module?.default === "function"
          ? module.default
          : typeof (module as { pdfParse?: unknown })?.pdfParse === "function"
          ? (module as { pdfParse: (buffer: Buffer) => Promise<{ text: string }> }).pdfParse
          : null;

      if (!candidate) {
        throw new Error(
          "Unable to load pdf-parse. Ensure the dependency exports a callable parser function.",
        );
      }

      return candidate as (buffer: Buffer) => Promise<{ text: string }>;
    });
  }

  return pdfParseLoader;
}
