import { createTool } from "@mastra/core/tools";
import { MCPClient } from "@mastra/mcp";
import { RuntimeContext } from "@mastra/core/runtime-context";
import type { ToolsInput } from "@mastra/core/agent";
import type { MastraMCPServerDefinition } from "@mastra/mcp";
import { z } from "zod";

const MARKITDOWN_TOOL_ID = "markitdown_convert_to_markdown";
const DEFAULT_MARKITDOWN_URL = "http://127.0.0.1:3001/mcp";
const DEFAULT_TIMEOUT = 120_000;

let markitdownClient: MCPClient | null = null;
let markitdownToolsPromise: Promise<ToolsInput> | null = null;
let localFallbackToolset: ToolsInput | null = null;
let pdfParseLoader: Promise<(input: Buffer) => Promise<{ text: string }>> | null = null;
let pdfWorkerConfigured = false;
let pdfWorkerSrcPromise: Promise<string | null> | null = null;

function parseTimeout(): number {
  const value = process.env.MARKITDOWN_MCP_TIMEOUT;
  if (!value) {
    return DEFAULT_TIMEOUT;
  }
  const parsed = Number.parseInt(value, 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : DEFAULT_TIMEOUT;
}

function parseHeaders(): Record<string, string> | undefined {
  const raw = process.env.MARKITDOWN_MCP_HEADERS;
  if (!raw) {
    return undefined;
  }

  try {
    const parsed = JSON.parse(raw) as Record<string, unknown>;
    return Object.fromEntries(
      Object.entries(parsed).map(([key, value]) => [key, String(value)]),
    );
  } catch (error) {
    console.warn(
      "[markitdown] Failed to parse MARKITDOWN_MCP_HEADERS as JSON. Expected object of header key/value pairs.",
      error,
    );
    return undefined;
  }
}

function resolveServerDefinition(timeout: number): MastraMCPServerDefinition {
  const rawUrl = process.env.MARKITDOWN_MCP_URL?.trim() ?? DEFAULT_MARKITDOWN_URL;

  let url: URL;
  try {
    url = new URL(rawUrl);
  } catch (error) {
    throw new Error(
      `Invalid MARKITDOWN_MCP_URL value '${rawUrl}'. Provide a fully qualified URL (e.g. http://127.0.0.1:3001/mcp).`,
      error instanceof Error ? { cause: error } : undefined,
    );
  }

  const headers = parseHeaders();

  return {
    url,
    timeout,
    requestInit: headers ? { headers } : undefined,
  };
}

async function ensureClient(): Promise<MCPClient> {
  if (markitdownClient) {
    return markitdownClient;
  }

  const timeout = parseTimeout();
  const serverDefinition = resolveServerDefinition(timeout);

  markitdownClient = new MCPClient({
    servers: {
      markitdown: serverDefinition,
    },
    timeout,
  });

  return markitdownClient;
}

async function ensureTools(): Promise<ToolsInput> {
  if (markitdownToolsPromise) {
    return markitdownToolsPromise;
  }

  markitdownToolsPromise = (async () => {
    const client = await ensureClient();
    const tools = await client.getTools();

    if (!tools[MARKITDOWN_TOOL_ID]) {
      throw new Error(
        `MarkItDown MCP server did not expose '${MARKITDOWN_TOOL_ID}'. Ensure the server is running and reachable.`,
      );
    }

    return tools;
  })();

  try {
    return await markitdownToolsPromise;
  } catch (error) {
    markitdownToolsPromise = null;
    throw error;
  }
}

function extractMarkdown(callResult: unknown): string {
  if (typeof callResult === "string") {
    return callResult;
  }

  if (
    callResult &&
    typeof callResult === "object" &&
    "content" in callResult &&
    Array.isArray((callResult as { content: unknown }).content)
  ) {
    const { content } = callResult as { content: Array<Record<string, unknown>> };
    for (const item of content) {
      if (typeof item?.text === "string") {
        return item.text;
      }
    }
  }

  throw new Error("MarkItDown MCP response did not include text content.");
}

export async function getMarkitdownTools(): Promise<ToolsInput> {
  try {
    return await ensureTools();
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error while loading MarkItDown tools.";
    console.warn(
      `[markitdown] Remote tool unavailable; using local fallback implementation. Reason: ${message}`,
    );

    if (localFallbackToolset) {
      return localFallbackToolset;
    }

    const fallbackTool = createTool({
      id: MARKITDOWN_TOOL_ID,
      description:
        "Convert PDF data URIs into markdown using a local parser when the MarkItDown MCP server is unavailable.",
      inputSchema: z.object({
        uri: z
          .string()
          .min(1, "Provide a data URI to convert to markdown.")
          .describe("Data URI (base64) representation of the PDF document."),
      }),
      outputSchema: z.object({
        markdown: z
          .string()
          .describe("Extracted markdown text generated by the local PDF parser."),
        note: z
          .string()
          .optional()
          .describe("Status message describing limitations of the local parser."),
      }),
      execute: async ({ context }) => {
        const markdown = await convertUriToMarkdown(context.uri, { preferLocal: true });
        return {
          markdown,
          note:
            "Converted using local PDF parser fallback. Formatting may differ from MarkItDown output.",
        };
      },
    });

    localFallbackToolset = {
      [MARKITDOWN_TOOL_ID]: fallbackTool,
    };

    return localFallbackToolset;
  }
}

interface ConvertOptions {
  preferLocal?: boolean;
}

export async function convertUriToMarkdown(
  uri: string,
  options?: ConvertOptions,
): Promise<string> {
  if (!uri || typeof uri !== "string") {
    throw new Error("A non-empty URI is required to convert with MarkItDown.");
  }

  if (!options?.preferLocal) {
    try {
      const tools = await ensureTools();
      const tool = tools[MARKITDOWN_TOOL_ID];

      if (!tool?.execute) {
        throw new Error(
          "MarkItDown tool is not executable. Verify the MCP server configuration.",
        );
      }

      const runtimeContext = new RuntimeContext();
      const execute = tool.execute as (
        context: Parameters<NonNullable<typeof tool.execute>>[0],
        options?: Parameters<NonNullable<typeof tool.execute>>[1],
      ) => Promise<unknown>;
      const result = await execute({
        context: { uri },
        runtimeContext,
      });

      return extractMarkdown(result);
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "MarkItDown MCP request failed unexpectedly.";
      console.warn(
        `[markitdown] Remote conversion failed. Attempting local PDF fallback. Reason: ${message}`,
      );
      const fallback = await tryLocalPdfFallback(uri);
      if (fallback) {
        return fallback;
      }

      throw new Error(
        `MarkItDown MCP failed (${message}) and no local fallback conversion was available.`,
      );
    }
  }

  const fallback = await tryLocalPdfFallback(uri);
  if (fallback) {
    return fallback;
  }

  throw new Error(
    "Local MarkItDown fallback only supports PDF data URIs. Provide a PDF or configure the MCP server.",
  );
}

export function resetMarkitdownClientForTests(): void {
  markitdownClient = null;
  markitdownToolsPromise = null;
  localFallbackToolset = null;
  pdfParseLoader = null;
  pdfWorkerConfigured = false;
  pdfWorkerSrcPromise = null;
}

interface ParsedDataUri {
  mimeType: string;
  buffer: Buffer;
}

const DATA_URI_REGEX = /^data:([^;]+);base64,(.+)$/i;

function parseDataUri(uri: string): ParsedDataUri | null {
  const match = uri.match(DATA_URI_REGEX);
  if (!match) {
    return null;
  }

  const [, mimeType, base64] = match;
  try {
    return {
      mimeType,
      buffer: Buffer.from(base64, "base64"),
    };
  } catch {
    return null;
  }
}

async function tryLocalPdfFallback(uri: string): Promise<string | null> {
  const parsed = parseDataUri(uri);
  if (!parsed || parsed.mimeType.toLowerCase() !== "application/pdf") {
    return null;
  }

  try {
    const pdfParse = await loadPdfParse();
    const result = await pdfParse(parsed.buffer);
    const normalized = normalizePdfText(result.text);
    if (normalized) {
      return normalized;
    }
    return "_No textual content could be extracted from the PDF._";
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Unknown error during local PDF parsing.";
    console.error(`[markitdown] Local PDF fallback failed: ${message}`, error);
    throw new Error(`Local PDF fallback failed: ${message}`);
  }
}

function normalizePdfText(text: string): string {
  const normalized = text
    .replace(/\r\n/g, "\n")
    .split("\n")
    .map((line) => line.trimEnd())
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();

  if (!normalized) {
    return "";
  }

  const paragraphs = normalized
    .split(/\n{2,}/)
    .map((paragraph) => paragraph.replace(/\n/g, " ").replace(/\s{2,}/g, " ").trim())
    .filter(Boolean);

  return paragraphs.length > 0 ? paragraphs.join("\n\n") : normalized;
}

async function loadPdfParse(): Promise<(input: Buffer) => Promise<{ text: string }>> {
  if (!pdfParseLoader) {
    pdfParseLoader = import("pdf-parse").then((module: unknown) => {
      const defaultExport =
        typeof module === "object" && module !== null ? (module as { default?: unknown }).default : undefined;
      const namedExport =
        typeof module === "object" && module !== null ? (module as { pdfParse?: unknown }).pdfParse : undefined;
      const pdfParseClass =
        typeof module === "object" && module !== null ? (module as { PDFParse?: unknown }).PDFParse : undefined;

      if (typeof module === "function") {
        return module as (buffer: Buffer) => Promise<{ text: string }>;
      }

      if (typeof defaultExport === "function") {
        return defaultExport as (buffer: Buffer) => Promise<{ text: string }>;
      }

      if (typeof namedExport === "function") {
        return namedExport as (buffer: Buffer) => Promise<{ text: string }>;
      }

      if (typeof pdfParseClass === "function") {
        return async (buffer: Buffer) => {
          await ensurePdfWorkerConfigured(pdfParseClass as { setWorker?: (src: string) => unknown });

          const Parser = pdfParseClass as new (options: { data: Buffer }) => {
            getText: () => Promise<{ text: string }>;
            destroy?: () => Promise<void>;
          };

          const parser = new Parser({ data: buffer });
          try {
            const result = await parser.getText();
            return { text: result?.text ?? "" };
          } finally {
            if (typeof parser.destroy === "function") {
              await parser.destroy();
            }
          }
        };
      }

      throw new Error("Unable to load pdf-parse. Ensure the dependency exports a callable parser function.");
    });
  }

  return pdfParseLoader;
}

async function ensurePdfWorkerConfigured(Parser: {
  setWorker?: (src: string) => unknown;
}): Promise<void> {
  if (pdfWorkerConfigured) {
    return;
  }

  if (typeof Parser.setWorker !== "function") {
    pdfWorkerConfigured = true;
    return;
  }

  const workerSrc = await resolvePdfWorkerSrc();
  if (!workerSrc) {
    pdfWorkerConfigured = true;
    console.warn(
      "[markitdown] Unable to resolve pdf.js worker bundle. Local PDF fallback may fail.",
    );
    return;
  }

  try {
    Parser.setWorker(workerSrc);
  } catch (error) {
    console.warn(
      `[markitdown] Failed to configure pdf.js worker at ${workerSrc}. Local PDF fallback may fail.`,
      error,
    );
  } finally {
    pdfWorkerConfigured = true;
  }
}

async function resolvePdfWorkerSrc(): Promise<string | null> {
  if (!pdfWorkerSrcPromise) {
    pdfWorkerSrcPromise = (async () => {
      try {
        const { createRequire } = await import("node:module");
        const fs = await import("node:fs/promises");
        const path = await import("node:path");
        const require = createRequire(import.meta.url);
        const moduleCandidates = [
          "pdfjs-dist/legacy/build/pdf.worker.mjs",
          "pdfjs-dist/legacy/build/pdf.worker.js",
          "pdfjs-dist/build/pdf.worker.mjs",
          "pdfjs-dist/build/pdf.worker.js",
        ];

        let source: string | null = null;
        for (const candidate of moduleCandidates) {
          try {
            source = require.resolve(candidate);
            if (source) {
              break;
            }
          } catch {
            // Ignore missing candidates.
          }
        }

        if (!source) {
          return null;
        }

        const destinationDir = path.resolve(process.cwd(), ".next/server/chunks");
        const destinationPath = path.join(destinationDir, "pdf.worker.mjs");

        await fs.mkdir(destinationDir, { recursive: true });
        try {
          await fs.access(destinationPath);
        } catch {
          await fs.copyFile(source, destinationPath);
        }

        return destinationPath;
      } catch (error) {
        console.warn(
          "[markitdown] Failed to resolve pdf.js worker bundle via Node module loader.",
          error,
        );
      }

      return null;
    })();
  }

  return pdfWorkerSrcPromise;
}
